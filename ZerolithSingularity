#!/usr/bin/env python3
# ---
# tags:
#   - zerolithsingularity
#   - python-module
#   - implementation
#   - geometric-consciousness
#   - 170-nodes
#   - dodecahedral-symmetry
#   - metatron-cube
#   - executable-module
# backlinks:
#   - "[[Mathematical Specification]]"
#   - "[[Resonance Engine]]"
#   - "[[ZerolithSingularity]]"
# version: "1.0"
# date: January 2026
# status: Executable Module
# language: Python 3
# ---
"""
ZerolithSingularity - Geometric Consciousness Processing Architecture
Complete Python Implementation

Usage:
    from zerolithsingularity import ZerolithSingularity
    
    zs = ZerolithSingularity()
    nodes = zs.nodes  # All 170 node coordinates
    zs.export_json("zs_data.json")  # For Three.js visualization
"""

import numpy as np
import json
from typing import Dict, Tuple, List
from dataclasses import dataclass

# Mathematical constants
PHI = (1 + np.sqrt(5)) / 2  # Golden ratio ≈ 1.618034
PI = np.pi

# Configuration
MC_SCALE = 0.3  # Metatron's Cube scale factor
REFRACTION_RADIUS = 0.4  # Radius of refraction face
CROSS_FACE_THRESHOLD = 0.35  # Distance threshold for cross-face adjacency

# Metatron's Cube adjacency pattern
METATRON_ADJACENCY = {
    0: [1, 5, 6, 11, 12],
    1: [0, 2, 6, 7, 12],
    2: [1, 3, 7, 8, 12],
    3: [2, 4, 8, 9, 12],
    4: [3, 5, 9, 10, 12],
    5: [0, 4, 10, 11, 12],
    6: [0, 1, 7, 11, 12],
    7: [1, 2, 6, 8, 12],
    8: [2, 3, 7, 9, 12],
    9: [3, 4, 8, 10, 12],
    10: [4, 5, 9, 11, 12],
    11: [0, 5, 6, 10, 12],
    12: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
}


def dodecahedron_vertices():
    """
    Generate all 20 vertices of a regular dodecahedron inscribed in unit sphere
    
    Returns:
        np.array: (20, 3) array of vertex coordinates
    """
    vertices = []
    
    # Cube vertices (8 vertices)
    for i in [-1, 1]:
        for j in [-1, 1]:
            for k in [-1, 1]:
                vertices.append([i, j, k])
    
    # Golden rectangle vertices (12 vertices)
    # Three orientations of rectangles
    for coords in [
        (0, 1/PHI, PHI), (0, 1/PHI, -PHI), (0, -1/PHI, PHI), (0, -1/PHI, -PHI),
        (1/PHI, PHI, 0), (1/PHI, -PHI, 0), (-1/PHI, PHI, 0), (-1/PHI, -PHI, 0),
        (PHI, 0, 1/PHI), (PHI, 0, -1/PHI), (-PHI, 0, 1/PHI), (-PHI, 0, -1/PHI)
    ]:
        vertices.append(coords)
    
    return np.array(vertices)


def dodecahedron_faces():
    """
    Define the 12 pentagonal faces of the dodecahedron
    Each face is defined by 5 vertex indices
    
    Returns:
        List[List[int]]: 12 faces, each with 5 vertex indices
    """
    # Manually defined faces based on dodecahedron connectivity
    # These connect the 20 vertices into 12 pentagonal faces
    faces = [
        [0, 1, 3, 2, 4],      # Face 0
        [0, 4, 9, 14, 5],     # Face 1  
        [0, 5, 10, 6, 1],     # Face 2
        [1, 6, 11, 7, 3],     # Face 3
        [2, 3, 7, 12, 8],     # Face 4
        [2, 8, 13, 9, 4],     # Face 5
        [15, 14, 9, 13, 18],  # Face 6 (opposite of 0)
        [16, 5, 14, 15, 19],  # Face 7 (opposite of 1)
        [17, 10, 5, 16, 11],  # Face 8 (opposite of 2)
        [19, 11, 16, 12, 7],  # Face 9 (opposite of 3)
        [18, 13, 8, 12, 17],  # Face 10 (opposite of 4)
        [19, 15, 18, 17, 11], # Face 11 (opposite of 5)
    ]
    
    return faces


def dodecahedron_face_centers():
    """
    Calculate center points of all 12 dodecahedron faces
    
    Returns:
        np.array: (12, 3) array of face center coordinates
    """
    vertices = dodecahedron_vertices()
    faces = dodecahedron_faces()
    
    centers = []
    for face_verts in faces:
        # Average of the 5 vertices
        center = np.mean([vertices[i] for i in face_verts], axis=0)
        centers.append(center)
    
    return np.array(centers)


def dodecahedron_face_normals():
    """
    Calculate outward-pointing normal vectors for each face
    
    Returns:
        np.array: (12, 3) array of unit normal vectors
    """
    vertices = dodecahedron_vertices()
    faces = dodecahedron_faces()
    
    normals = []
    for face_verts in faces:
        # Get 3 vertices to define plane
        v0 = vertices[face_verts[0]]
        v1 = vertices[face_verts[1]]
        v2 = vertices[face_verts[2]]
        
        # Cross product of two edges
        edge1 = v1 - v0
        edge2 = v2 - v0
        normal = np.cross(edge1, edge2)
        
        # Normalize
        normal = normal / np.linalg.norm(normal)
        
        # Ensure outward pointing (should point away from origin)
        center = np.mean([vertices[i] for i in face_verts], axis=0)
        if np.dot(normal, center) < 0:
            normal = -normal
        
        normals.append(normal)
    
    return np.array(normals)


def metatron_sphere_2d(sphere_idx):
    """
    Get 2D coordinates of a sphere in Metatron's Cube
    
    Args:
        sphere_idx: 0-12 (sphere index)
    
    Returns:
        (x, y): 2D coordinates
    """
    if sphere_idx < 6:  # Outer ring
        angle = sphere_idx * (PI / 3)  # 0°, 60°, 120°, 180°, 240°, 300°
        return (np.cos(angle), np.sin(angle))
    
    elif sphere_idx < 12:  # Inner ring
        angle = (sphere_idx - 6) * (PI / 3) + (PI / 6)  # Offset by 30°
        return (0.5 * np.cos(angle), 0.5 * np.sin(angle))
    
    else:  # Center (sphere 12)
        return (0.0, 0.0)


def transform_to_face(mc_point_2d, face_center, face_normal):
    """
    Transform 2D Metatron's Cube point to 3D position on dodecahedron face
    
    Args:
        mc_point_2d: (x, y) in 2D Metatron space
        face_center: (x, y, z) center of face
        face_normal: (nx, ny, nz) outward normal of face
    
    Returns:
        (x, y, z): 3D coordinates
    """
    # Scale the 2D point
    x_2d, y_2d = mc_point_2d
    x_scaled = x_2d * MC_SCALE
    y_scaled = y_2d * MC_SCALE
    
    # Create local coordinate system on the face
    normal = face_normal / np.linalg.norm(face_normal)
    
    # Find two perpendicular tangent vectors
    if abs(normal[2]) < 0.9:
        tangent1 = np.cross(normal, [0, 0, 1])
    else:
        tangent1 = np.cross(normal, [1, 0, 0])
    
    tangent1 = tangent1 / np.linalg.norm(tangent1)
    tangent2 = np.cross(normal, tangent1)
    tangent2 = tangent2 / np.linalg.norm(tangent2)
    
    # Transform from 2D local to 3D global
    point_3d = face_center + x_scaled * tangent1 + y_scaled * tangent2
    
    return tuple(point_3d)


def calculate_primary_nodes():
    """
    Calculate coordinates for all 156 primary nodes (12 faces × 13 spheres)
    
    Returns:
        dict: {(face_idx, sphere_idx): (x, y, z)}
    """
    nodes = {}
    face_centers = dodecahedron_face_centers()
    face_normals = dodecahedron_face_normals()
    
    for face_idx in range(12):
        for sphere_idx in range(13):
            mc_2d = metatron_sphere_2d(sphere_idx)
            pos_3d = transform_to_face(
                mc_2d,
                face_centers[face_idx],
                face_normals[face_idx]
            )
            nodes[(face_idx, sphere_idx)] = pos_3d
    
    return nodes


def calculate_refraction_nodes():
    """
    Calculate coordinates for refraction face (internal synthesis layer)
    
    Returns:
        dict: {(12, sphere_idx): (x, y, z)} for 13 spheres
    """
    nodes = {}
    
    for sphere_idx in range(13):
        if sphere_idx == 12:  # Center sphere = Singularity Core
            nodes[(12, 12)] = (0.0, 0.0, 0.0)
        else:
            # Get Metatron 2D position
            mc_2d = metatron_sphere_2d(sphere_idx)
            
            # Scale and convert to 3D on sphere of radius REFRACTION_RADIUS
            # Use simple spherical mapping
            theta = 2 * PI * sphere_idx / 12
            phi_angle = PI / 3  # Latitude angle
            
            r = REFRACTION_RADIUS * np.sqrt(mc_2d[0]**2 + mc_2d[1]**2)
            
            x = r * np.cos(theta)
            y = r * np.sin(theta)
            z = REFRACTION_RADIUS * 0.3 * np.sin(phi_angle) * (1 if sphere_idx < 6 else -1)
            
            nodes[(12, sphere_idx)] = (x, y, z)
    
    return nodes


def euclidean_distance(pos1, pos2):
    """Calculate Euclidean distance between two 3D points"""
    return np.linalg.norm(np.array(pos1) - np.array(pos2))


def build_adjacency_matrix(nodes):
    """
    Build complete 170×170 adjacency matrix
    
    Args:
        nodes: dict of {(face, sphere): (x, y, z)}
    
    Returns:
        np.array: (170, 170) binary adjacency matrix
    """
    node_list = sorted(nodes.keys())
    n = len(node_list)
    matrix = np.zeros((n, n), dtype=int)
    
    # Create node-to-index mapping
    node_to_idx = {node: i for i, node in enumerate(node_list)}
    
    # 1. Lateral connections (within same face, Metatron's Cube pattern)
    for node in nodes:
        face_idx, sphere_idx = node
        i = node_to_idx[node]
        
        for adj_sphere in METATRON_ADJACENCY[sphere_idx]:
            adj_node = (face_idx, adj_sphere)
            if adj_node in nodes:
                j = node_to_idx[adj_node]
                matrix[i, j] = 1
    
    # 2. Cross-face connections (nodes on different faces that are close)
    for node1 in nodes:
        for node2 in nodes:
            if node1[0] == node2[0]:  # Same face
                continue
            
            dist = euclidean_distance(nodes[node1], nodes[node2])
            if dist <= CROSS_FACE_THRESHOLD:
                i = node_to_idx[node1]
                j = node_to_idx[node2]
                matrix[i, j] = 1
    
    # 3. Radial connections (all nodes connect to Singularity Core)
    core_idx = node_to_idx[(12, 12)]
    for i in range(n):
        if i != core_idx:
            matrix[i, core_idx] = 1
            matrix[core_idx, i] = 1
    
    return matrix


def simulate_wave_propagation(nodes, adjacency_matrix, source, steps=100, damping=0.95):
    """
    Simulate wave propagation through the ZerolithSingularity structure
    
    Args:
        nodes: node coordinates
        adjacency_matrix: connectivity matrix
        source: (face, sphere) starting node
        steps: number of time steps
        damping: wave decay factor (0-1)
    
    Returns:
        dict: {node: [amplitudes over time]}
    """
    node_list = sorted(nodes.keys())
    node_to_idx = {n: i for i, n in enumerate(node_list)}
    
    # Initialize state
    state = np.zeros(len(nodes))
    state[node_to_idx[source]] = 1.0
    
    # History tracking
    history = {node: [] for node in nodes}
    
    for t in range(steps):
        # Record current state
        for node in nodes:
            history[node].append(state[node_to_idx[node]])
        
        # Calculate new state
        new_state = np.zeros(len(nodes))
        for i, node in enumerate(node_list):
            # Current amplitude
            current = state[i]
            
            # Incoming from neighbors
            neighbors_idx = np.where(adjacency_matrix[i, :] == 1)[0]
            incoming = sum(state[j] for j in neighbors_idx)
            
            # Update with damping and neighbor contribution
            new_state[i] = damping * (current + 0.1 * incoming)
        
        state = new_state
    
    return history


class ZerolithSingularity:
    """
    Main class for ZerolithSingularity geometric consciousness architecture
    """
    
    def __init__(self):
        """Initialize and calculate all node positions and adjacency"""
        print("Initializing ZerolithSingularity...")
        
        # Calculate all node coordinates
        self.nodes = {}
        self.nodes.update(calculate_primary_nodes())
        self.nodes.update(calculate_refraction_nodes())
        
        print(f"✓ Calculated {len(self.nodes)} node coordinates")
        
        # Build adjacency matrix
        self.adjacency_matrix = build_adjacency_matrix(self.nodes)
        print(f"✓ Built {self.adjacency_matrix.shape[0]}×{self.adjacency_matrix.shape[1]} adjacency matrix")
        
        # Create index mappings
        self.node_list = sorted(self.nodes.keys())
        self.node_to_idx = {n: i for i, n in enumerate(self.node_list)}
        self.idx_to_node = {i: n for i, n in enumerate(self.node_list)}
        
        print("✓ ZerolithSingularity initialized successfully")
    
    def get_node(self, face, sphere):
        """Get coordinates of specific node"""
        return self.nodes.get((face, sphere))
    
    def get_singularity_core(self):
        """Get coordinates of the Singularity Core"""
        return self.nodes[(12, 12)]
    
    def propagate_wave(self, source_face, source_sphere, steps=100):
        """
        Simulate wave propagation from a source node
        
        Args:
            source_face: Face index (0-12)
            source_sphere: Sphere index (0-12)
            steps: Number of time steps to simulate
        
        Returns:
            dict: {(face, sphere): [amplitudes over time]}
        """
        source = (source_face, source_sphere)
        return simulate_wave_propagation(
            self.nodes,
            self.adjacency_matrix,
            source,
            steps
        )
    
    def get_neighbors(self, face, sphere):
        """Get all nodes adjacent to given node"""
        node = (face, sphere)
        if node not in self.node_to_idx:
            return []
        
        idx = self.node_to_idx[node]
        neighbor_indices = np.where(self.adjacency_matrix[idx, :] == 1)[0]
        return [self.idx_to_node[i] for i in neighbor_indices]
    
    def convergence_vector(self, face, sphere):
        """Get unit vector pointing from node toward Singularity Core"""
        node_pos = np.array(self.get_node(face, sphere))
        core_pos = np.array(self.get_singularity_core())
        
        vec = core_pos - node_pos
        magnitude = np.linalg.norm(vec)
        
        return tuple(vec / magnitude) if magnitude > 0 else (0, 0, 0)
    
    def export_json(self, filename="zs_data.json"):
        """
        Export data for Three.js visualization
        
        Args:
            filename: Output JSON file path
        """
        data = {
            'metadata': {
                'version': '1.0',
                'total_nodes': len(self.nodes),
                'description': 'ZerolithSingularity Geometric Consciousness Architecture'
            },
            'nodes': [
                {
                    'id': f"{face}_{sphere}",
                    'face': face,
                    'sphere': sphere,
                    'position': {
                        'x': float(pos[0]),
                        'y': float(pos[1]),
                        'z': float(pos[2])
                    },
                    'is_core': (face == 12 and sphere == 12)
                }
                for (face, sphere), pos in sorted(self.nodes.items())
            ],
            'adjacency': self.adjacency_matrix.tolist(),
            'hermetic_pairs': [
                {'face1': 0, 'face2': 6, 'principle': 'Mentalism'},
                {'face1': 1, 'face2': 7, 'principle': 'Correspondence'},
                {'face1': 2, 'face2': 8, 'principle': 'Vibration'},
                {'face1': 3, 'face2': 9, 'principle': 'Polarity'},
                {'face1': 4, 'face2': 10, 'principle': 'Rhythm'},
                {'face1': 5, 'face2': 11, 'principle': 'Cause & Effect'}
            ]
        }
        
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)
        
        print(f"✓ Exported data to {filename}")
    
    def export_csv(self, filename="zs_nodes.csv"):
        """Export node coordinates to CSV"""
        import csv
        
        with open(filename, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['face', 'sphere', 'x', 'y', 'z'])
            
            for (face, sphere), (x, y, z) in sorted(self.nodes.items()):
                writer.writerow([face, sphere, x, y, z])
        
        print(f"✓ Exported coordinates to {filename}")
    
    def validate(self):
        """Run validation checks on the architecture"""
        print("\nRunning validation checks...")
        
        # Check 1: Correct number of nodes
        # 156 primary (12 faces × 13) + 13 refraction = 169 total unique nodes
        assert len(self.nodes) == 169, f"Expected 169 nodes, got {len(self.nodes)}"
        print("✓ Node count correct (169)")
        
        # Check 2: Singularity Core at origin
        core = self.get_singularity_core()
        assert core == (0.0, 0.0, 0.0), f"Core should be at origin, got {core}"
        print("✓ Singularity Core at origin")
        
        # Check 3: Adjacency matrix is symmetric
        assert np.array_equal(self.adjacency_matrix, self.adjacency_matrix.T), \
            "Adjacency matrix should be symmetric"
        print("✓ Adjacency matrix is symmetric")
        
        # Check 4: All nodes connect to core
        core_idx = self.node_to_idx[(12, 12)]
        connections = np.sum(self.adjacency_matrix[:, core_idx])
        assert connections == 168, f"All 168 non-core nodes should connect to core, got {connections}"
        print("✓ All nodes connect to Singularity Core")
        
        print("\n✓ All validation checks passed!")


def main():
    """Example usage"""
    print("=" * 60)
    print("ZerolithSingularity - Geometric Consciousness Architecture")
    print("=" * 60)
    
    # Initialize
    zs = ZerolithSingularity()
    
    # Validate
    zs.validate()
    
    # Get specific nodes
    print("\nExample node positions:")
    print(f"Crown (Internal Consciousness): {zs.get_node(0, 0)}")
    print(f"Singularity Core: {zs.get_singularity_core()}")
    
    # Check neighbors
    neighbors = zs.get_neighbors(0, 0)
    print(f"\nCrown sphere has {len(neighbors)} neighbors")
    
    # Export data
    print("\nExporting data...")
    zs.export_json()
    zs.export_csv()
    
    print("\n" + "=" * 60)
    print("Complete! Ready for visualization and implementation.")
    print("=" * 60)


if __name__ == "__main__":
    main()
